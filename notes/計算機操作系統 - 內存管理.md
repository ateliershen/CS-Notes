<!-- GFM-TOC -->
* [虛擬內存](#虛擬內存)
* [分頁系統地址映射](#分頁系統地址映射)
* [頁面置換算法](#頁面置換算法)
    * [1. 最佳](#1-最佳)
    * [2. 最近最久未使用](#2-最近最久未使用)
    * [3. 最近未使用](#3-最近未使用)
    * [4. 先進先出](#4-先進先出)
    * [5. 第二次機會算法](#5-第二次機會算法)
    * [6. 時鐘](#6-時鐘)
* [分段](#分段)
* [段頁式](#段頁式)
* [分頁與分段的比較](#分頁與分段的比較)
<!-- GFM-TOC -->


# 虛擬內存

虛擬內存的目的是為了讓物理內存擴充成更大的邏輯內存，從而讓程序獲得更多的可用內存。

為了更好的管理內存，操作系統將內存抽象成地址空間。每個程序擁有自己的地址空間，這個地址空間被分割成多個塊，每一塊稱為一頁。這些頁被映射到物理內存，但不需要映射到連續的物理內存，也不需要所有頁都必須在物理內存中。當程序引用到不在物理內存中的頁時，由硬件執行必要的映射，將缺失的部分裝入物理內存並重新執行失敗的指令。

從上面的描述中可以看出，虛擬內存允許程序不用將地址空間中的每一頁都映射到物理內存，也就是說一個程序不需要全部調入內存就可以運行，這使得有限的內存運行大程序成為可能。例如有一臺計算機可以產生 16 位地址，那麼一個程序的地址空間範圍是 0\~64K。該計算機只有 32KB 的物理內存，虛擬內存技術允許該計算機運行一個 64K 大小的程序。

<div align="center"> <img src="pics/7b281b1e-0595-402b-ae35-8c91084c33c1.png"/> </div><br>

# 分頁系統地址映射

內存管理單元（MMU）管理著地址空間和物理內存的轉換，其中的頁表（Page table）存儲著頁（程序地址空間）和頁框（物理內存空間）的映射表。

一個虛擬地址分成兩個部分，一部分存儲頁面號，一部分存儲偏移量。

下圖的頁表存放著 16 個頁，這 16 個頁需要用 4 個比特位來進行索引定位。例如對於虛擬地址（0010 000000000100），前 4 位是存儲頁面號 2，讀取表項內容為（110 1），頁表項最後一位表示是否存在於內存中，1 表示存在。後 12 位存儲偏移量。這個頁對應的頁框的地址為 （110 000000000100）。

<div align="center"> <img src="pics/cf4386a1-58c9-4eca-a17f-e12b1e9770eb.png" width="500"/> </div><br>

# 頁面置換算法

在程序運行過程中，如果要訪問的頁面不在內存中，就發生缺頁中斷從而將該頁調入內存中。此時如果內存已無空閒空間，系統必須從內存中調出一個頁面到磁盤對換區中來騰出空間。

頁面置換算法和緩存淘汰策略類似，可以將內存看成磁盤的緩存。在緩存系統中，緩存的大小有限，當有新的緩存到達時，需要淘汰一部分已經存在的緩存，這樣才有空間存放新的緩存數據。

頁面置換算法的主要目標是使頁面置換頻率最低（也可以說缺頁率最低）。

## 1. 最佳

> OPT, Optimal replacement algorithm

所選擇的被換出的頁面將是最長時間內不再被訪問，通常可以保證獲得最低的缺頁率。

是一種理論上的算法，因為無法知道一個頁面多長時間不再被訪問。

舉例：一個系統為某進程分配了三個物理塊，並有如下頁面引用序列：

```html
7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1
```

開始運行時，先將 7, 0, 1 三個頁面裝入內存。當進程要訪問頁面 2 時，產生缺頁中斷，會將頁面 7 換出，因為頁面 7 再次被訪問的時間最長。

## 2. 最近最久未使用

> LRU, Least Recently Used

雖然無法知道將來要使用的頁面情況，但是可以知道過去使用頁面的情況。LRU 將最近最久未使用的頁面換出。

為了實現 LRU，需要在內存中維護一個所有頁面的鏈表。當一個頁面被訪問時，將這個頁面移到鏈表表頭。這樣就能保證鏈表表尾的頁面是最近最久未訪問的。

因為每次訪問都需要更新鏈表，因此這種方式實現的 LRU 代價很高。

```html
4，7，0，7，1，0，1，2，1，2，6
```

<div align="center"> <img src="pics/eb859228-c0f2-4bce-910d-d9f76929352b.png"/> </div><br>

## 3. 最近未使用

> NRU, Not Recently Used

每個頁面都有兩個狀態位：R 與 M，當頁面被訪問時設置頁面的 R=1，當頁面被修改時設置 M=1。其中 R 位會定時被清零。可以將頁面分成以下四類：

- R=0，M=0
- R=0，M=1
- R=1，M=0
- R=1，M=1

當發生缺頁中斷時，NRU 算法隨機地從類編號最小的非空類中挑選一個頁面將它換出。

NRU 優先換出已經被修改的髒頁面（R=0，M=1），而不是被頻繁使用的乾淨頁面（R=1，M=0）。

## 4. 先進先出

> FIFO, First In First Out

選擇換出的頁面是最先進入的頁面。

該算法會將那些經常被訪問的頁面也被換出，從而使缺頁率升高。

## 5. 第二次機會算法

FIFO 算法可能會把經常使用的頁面置換出去，為了避免這一問題，對該算法做一個簡單的修改：

當頁面被訪問 (讀或寫) 時設置該頁面的 R 位為 1。需要替換的時候，檢查最老頁面的 R 位。如果 R 位是 0，那麼這個頁面既老又沒有被使用，可以立刻置換掉；如果是 1，就將 R 位清 0，並把該頁面放到鏈表的尾端，修改它的裝入時間使它就像剛裝入的一樣，然後繼續從鏈表的頭部開始搜索。

<div align="center"> <img src="pics/ecf8ad5d-5403-48b9-b6e7-f2e20ffe8fca.png"/> </div><br>

## 6. 時鐘

> Clock

第二次機會算法需要在鏈表中移動頁面，降低了效率。時鐘算法使用環形鏈表將頁面連接起來，再使用一個指針指向最老的頁面。

<div align="center"> <img src="pics/5f5ef0b6-98ea-497c-a007-f6c55288eab1.png"/> </div><br>

# 分段

虛擬內存採用的是分頁技術，也就是將地址空間劃分成固定大小的頁，每一頁再與內存進行映射。

下圖為一個編譯器在編譯過程中建立的多個表，有 4 個表是動態增長的，如果使用分頁系統的一維地址空間，動態增長的特點會導致覆蓋問題的出現。

<div align="center"> <img src="pics/22de0538-7c6e-4365-bd3b-8ce3c5900216.png"/> </div><br>

分段的做法是把每個表分成段，一個段構成一個獨立的地址空間。每個段的長度可以不同，並且可以動態增長。

<div align="center"> <img src="pics/e0900bb2-220a-43b7-9aa9-1d5cd55ff56e.png"/> </div><br>

# 段頁式

程序的地址空間劃分成多個擁有獨立地址空間的段，每個段上的地址空間劃分成大小相同的頁。這樣既擁有分段系統的共享和保護，又擁有分頁系統的虛擬內存功能。

# 分頁與分段的比較

- 對程序員的透明性：分頁透明，但是分段需要程序員顯式劃分每個段。

- 地址空間的維度：分頁是一維地址空間，分段是二維的。

- 大小是否可以改變：頁的大小不可變，段的大小可以動態改變。

- 出現的原因：分頁主要用於實現虛擬內存，從而獲得更大的地址空間；分段主要是為了使程序和數據可以被劃分為邏輯上獨立的地址空間並且有助於共享和保護。




# 微信公眾號


更多精彩內容將發佈在微信公眾號 CyC2018 上，你也可以在公眾號後臺和我交流學習和求職相關的問題。另外，公眾號提供了該項目的 PDF 等離線閱讀版本，後臺回覆 "下載" 即可領取。公眾號也提供了一份技術面試複習大綱，不僅系統整理了面試知識點，而且標註了各個知識點的重要程度，從而幫你理清多而雜的面試知識點，後臺回覆 "大綱" 即可領取。我基本是按照這個大綱來進行復習的，對我拿到了 BAT 頭條等 Offer 起到很大的幫助。你們完全可以和我一樣根據大綱上列的知識點來進行復習，就不用看很多不重要的內容，也可以知道哪些內容很重要從而多安排一些複習時間。


<br><div align="center"><img width="320px" src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/other/公眾號海報6.png"></img></div>
